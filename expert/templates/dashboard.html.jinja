{% extends "layout.html.jinja" %}

{% block script %}
    <script src="https://cdn.socket.io/3.1.1/socket.io.min.js"
            integrity="sha384-gDaozqUvc4HTgo8iZjwth73C6dDDeOJsAgpxBcMpZYztUfjHXpzrpdrHRdVp8ySO"
            crossorigin="anonymous"></script>
    <script type="module">
     //document.getElementById('task-content').scrollTo(0, 0)
     window.scrollTo(0, 0)
    </script>

    <script type="module">

     import { Overlay, Dialog, ConfirmDialog } from '{{ exp_js }}/dialog.js';
     import { elt } from '{{ exp_js }}/util.js';
     import { Controller } from '{{ exp_js }}/controller.js'


     class SingleSelectorDialog extends Dialog {

         constructor(ctrlr, id = 'exp-dlg-download', template = 'download') {
             super(ctrlr, id, template);
         }

         async init() {
             await super.init();
             this.selectNode = this.node.querySelector(
                 '.exp-dlg-download-select');
             return this;
         }

         clearOptions() {
             while (this.selectNode.options.length) {
                 this.selectNode.remove(0);
             }
         }

     }

     class RunsDialog extends SingleSelectorDialog {

         async show(title, btnText, includeCurrent=true, onlyHasPii=false) {
             this.titlebar = title;
             this.run = null;
             this.selectNode.selectedIndex = 0;
             {# obj with keys:
             'id', 'num_complete', 'num_incomplete', 'has_pii'
             #}
             const runs = await this.ctrlr.api('get_runs');
             this.clearOptions();
             this.selectNode.add(new Option('Select a run'));
             for (const run of runs) {
                 if ((run.id === this.ctrlr.run && !includeCurrent) ||
                     (!run.has_pii && onlyHasPii)) {
                     continue;
                 }
                 const txt =
                     `${run.id} (${run.num_complete}, ${run.num_incomplete})`;
                 this.selectNode.add(new Option(txt));
             }
             const selectionChanged = () => {
                 this.run = null;
                 if (this.selectNode.selectedIndex) {
                     const len = this.selectNode.value.split(' ')[0].length;
                     this.run = this.selectNode.value.slice(0, len);
                 }
                 this.setButtonsDisabled({okay: !this.run});
             }
             this.selectNode.addEventListener('change', selectionChanged);
             this.setButtons(
                 [{tag: 'cancel', text: 'Cancel'},
                  {tag: 'okay', text: btnText, disabled: true}]);
             let tag = await super.show(() => this.buttons['okay'][0].focus());
             this.selectNode.removeEventListener('change', selectionChanged);
             return tag === 'okay';
         }
     }

     class BundlesDialog extends SingleSelectorDialog {

         constructor(ctrlr) {
             super(ctrlr, 'exp-dlg-load', 'load_bundle');
         }

         async init() {
             await super.init();
             // Can't use elt() here bc we're not added to the document yet
             this.toolCboxNode = this.node.querySelector(
                 '#exp-dlg-load-tool-cbox');
             return this;
         }

         async show(title, btnText) {
             this.titlebar = title;
             this.run = null;
             this.selectNode.selectedIndex = 0;
             const bundles = await this.ctrlr.api('get_bundles');
             this.clearOptions();
             this.selectNode.add(new Option('Select a bundle'));
             for (const bundle of bundles) {
                 this.selectNode.add(new Option(bundle));
             }
             const selectionChanged = () => {
                 this.bundle = null;
                 if (this.selectNode.selectedIndex) {
                     this.bundle = this.selectNode.value;
                 }
                 this.setButtonsDisabled({okay: !this.bundle});
             }
             this.selectNode.addEventListener('change', selectionChanged);
             this.setButtons(
                 [{tag: 'cancel', text: 'Cancel'},
                  {tag: 'okay', text: btnText, disabled: true}]);
             let tag = await super.show(() => this.buttons['okay'][0].focus());
             this.selectNode.removeEventListener('change', selectionChanged);
             this.toolMode = this.toolCboxNode.checked;
             return tag === 'okay';
         }
     }

     class InstList {

         constructor() {
             this.instDataNode = elt('inst-data');
             this.cellClasses = [
                 'dboard-num', 'dboard-id', 'dboard-clientip',
                 'dboard-profile', 'dboard-state', 'dboard-task',
                 'dboard-started', 'dboard-elapsed'];
             this.numRows = 0;
             this.numCols = this.cellClasses.length;
         }

         newRow(subjid) {
             const divs = [];
             for (let i = 0; i < this.numCols; i++) {
                 divs.push(document.createElement('div'));
                 this.instDataNode.append(divs[i]);
                 divs[i].classList.add(this.cellClasses[i], 'dboard-item');
             }
             divs[0].innerHTML = ++this.numRows;
             divs[1].dataset.subjid = subjid;
             return divs;
         }

         getRow(subjid) {
             const subjidDiv = this.instDataNode.querySelector(
                 `div[data-subjid="${subjid}"]`);
             if (subjidDiv) {
                 const divs = [subjidDiv];
                 for (let i=2; i<this.numCols; i++) {
                     divs.push(divs.at(-1).nextElementSibling);
                 }
                 return divs;
             }
         }

         setRow(subjid, fields, start=0, end=null) {
             // NB: if end is set, it must be non-negative
             if (end === null) {
                 end = this.numCols - 1;
             }
             const divs = this.getRow(subjid);
             for (let i=start; i<end; i++) {
                 divs[i].innerHTML = fields[i - start];
             }
         }

         addInst(inst) {
             this.newRow(inst[0]);
             this.setRow(inst[0], inst);
         }

         addStopSeparator(run) {
             const div = document.createElement('div');
             div.className = 'dboard-stop-sep';
             div.textContent = `Run ${run} stopped early`;
             this.instDataNode.append(div);
         }

         addReloadSeparator(bundleName) {
             const div = document.createElement('div');
             div.className = 'dboard-reload-sep';
             div.textContent = `Bundle '${bundleName}' reloaded`;
             this.instDataNode.append(div);
         }

         addEndSeparator(run) {
             const div = document.createElement('div');
             div.className = 'dboard-end-sep';
             div.textContent = `Run ${run} complete`;
             this.instDataNode.append(div);
         }

         updateInst(inst) {
             this.setRow(inst[0], inst);
         }

         update(insts) {
             for (let i = this.numRows; i < insts.length; i++) {
                 this.newRow(insts[i][0]);
             }
             for (let i = 0; i < insts.length; i++) {
                 this.updateInst(insts[i]);
             }
         }

     }

     const exper = "{{ exp_app_name }}";

     class Dashboard extends Controller {

         async init() {
             this.uploadBtn = elt('upload-btn');
             this.loadBtn = elt('load-btn');
             this.newRunBtn = elt('new-run-btn');
             this.reloadBtn = elt('reload-btn');
             this.downloadBtn = elt('download-btn');
             //this.deleteBtn = elt('delete-btn');
             this.downloadIdBtn = elt('download-id-btn');
             this.deleteIdBtn = elt('delete-id-btn');
             await super.init();
         }

         _initSocket() {
             super._initSocket();
             this._socket.on('new_instance',
                             inst => this.instList.addInst(inst));
             this._socket.on('update_instance',
                             inst => this.instList.updateInst(inst));
             this._socket.on('run_complete', () => {
                 this.instList.addEndSeparator(this.run);
                 this.setRunInfo({run: 'not running'});
                 this.run = null;
             });
         }

         async _initViews() {
             this.uploadingOverlay = await new Overlay(
                 this, 'upload-ovl').init();
             this.uploadingOverlay.contentNode.textContent = 'Uploading...';
             this.bundlesDlg = await new BundlesDialog(this).init();
             this.runsDlg = await new RunsDialog(this).init();
             this.confirmDlg = await new ConfirmDialog(this).init();
             this.instList = new InstList();

             this.uploadBtn.addEventListener('click', async () => {
                 const resp = await this.uploadBundle();
                 if (!resp.ok) {
                     // XXX show error dialog
                 }
             });
             this.loadBtn.addEventListener('click', async () => {
                 this.loadBtn.disabled = true;
                 await this.loadBundle();
                 this.loadBtn.disabled = false;
             });
             this.newRunBtn.addEventListener('click', async () => {
                 this.newRunBtn.disabled = true;
                 await this.newRun();
                 this.newRunBtn.disabled = false;
             });
             this.reloadBtn.addEventListener('click', async () => {
                 this.reloadBtn.disabled = true;
                 await this.reloadBundle();
                 this.reloadBtn.disabled = false;
             });

             this.downloadBtn.addEventListener('click', async () => {
                 this.downloadBtn.disabled = true;
                 if (await this.runsDlg.show(
                     'Download Results', 'Download')) {
                     this.download(this.runsDlg.run, 'results');
                 }
                 this.downloadBtn.disabled = false;
             });
             /*this.deleteBtn.addEventListener('click', async () => {
                 this.deleteBtn.disabled = true;
                 if (await this.runsDlg.show(
                     'Delete Results', 'Delete', false) &&
                     await this.confirmDlg.show(
                         `Really delete results for run ${this.runsDlg.run}?`,
                         'Cancel', 'Delete')) {
                     await callApi(
                         this.socket, 'delete_runs', [this.runsDlg.run]);
                 }
                 this.deleteBtn.disabled = false;
             });*/
             this.downloadIdBtn.addEventListener('click', async () => {
                 this.downloadIdBtn.disabled = true;
                 if (await this.runsDlg.show(
                     'Download ID Mapping', 'Download', true, true)) {
                     this.download(this.runsDlg.run, 'id_mapping');
                 }
                 this.downloadIdBtn.disabled = false;
             });
             this.deleteIdBtn.addEventListener('click', async () => {
                 this.deleteIdBtn.disabled = true;
                 if (await this.runsDlg.show(
                     'Delete ID Mapping', 'Delete', false, true) &&
                     await this.confirmDlg.show(
                         `Really delete ID mapping for run ${this.runsDlg.run}?`,
                         'Cancel', 'Delete')) {
                     await this.api('delete_id_mappißngs', this.runsDlg.run);
                 }
                 this.deleteIdBtn.disabled = false;
             });
         }

         async _onSocketConnected() {
             await super._onSocketConnected();
             console.log('will init views');
             await this._initViews();
             console.log('did init views');
             const data = await this.api('dboard_init');
             this.vars = data.vars;
             this._onBundleUpdate();
             this.instList.update(data.insts);
             this.setRunInfo(data.run_info);
             this.run = data.run_info.run;
             console.log(
                 `initializing; bundle: ${this.vars['exp_app_name']};` +
                 ` run: ${this.run}`);
         }

         /**
            Called when a bundle has been loaded.
         */
         _onBundleUpdate() {
             if (this.vars['exp_app_name']) {
                 elt('bundle-name').textContent = this.vars['exp_app_name'];
                 this.newRunBtn.disabled = false;
                 this.reloadBtn.disabled = false;
                 this.downloadBtn.disabled = false;
                 this.downloadIdBtn.disabled = false;
                 this.deleteIdBtn.disabled = false;
             }
         }

         uploadBundle() {
             const input = elt('file-input');
             const url = `{{ dashboard_path }}/upload_bundle`;
             const formData = new FormData();
             let whitelist = ['cfg.json', 'src/', 'static/', 'templates/'];
             const blacklist = ['profiles/', 'runs/'];
             function aread(f) {
                 return new Promise(resolve => {
                     const reader = new FileReader();
                     const listener = () => {
                         reader.removeEventListener('load', listener);
                         resolve(reader.result);
                     };
                     reader.addEventListener('load', listener);
                     reader.readAsText(f);
                 });
             }
             return new Promise(resolve => {
                 const listener = async () => {
                     this.uploadBtn.disabled = true;
                     this.uploadingOverlay.show();
                     input.removeEventListener('change', listener, false);
                     const bundleName = input.files[0]
                                             .webkitRelativePath.split('/')[0];
                     let manifestF = null;
                     for (const file of input.files) {
                         const parts = file.webkitRelativePath.split('/');
                         if (parts[1] === 'exp_manifest.txt') {
                             manifestF = file;
                             break;
                         }
                     }
                     if (manifestF) {
                         const manifest = await aread(manifestF);
                         whitelist = whitelist.concat(
                             manifest.split('\n')
                                     .map(x => x.trim())
                                     .filter(x => x.length &&
                                                !blacklist.includes(x)));
                     }
                     const filtered = [];
                     for (const item of whitelist) {
                         const itemPath = `${bundleName}/${item}`;
                         for (const file of input.files) {
                             if (item[item.length - 1] === '/') {
                                 if (file.webkitRelativePath.startsWith(
                                     itemPath)) {
                                     filtered.push(file);
                                 }
                             } else {
                                 if (file.webkitRelativePath === itemPath) {
                                     filtered.push(file);
                                     break;
                                 }
                             }
                         }
                     }
                     for (const file of filtered) {
                         formData.set(file.webkitRelativePath, file);
                     }

                     const xhr = new XMLHttpRequest();
                     xhr.upload.addEventListener('progress', e => {
                         if (e.lengthComputable) {
                             const pct = Math.round((e.loaded*100)/e.total);
                             console.log('pct', pct);
                         }
                     }, false);
                     xhr.upload.addEventListener('load', e => {
                         //self.ctrl.update(100);
                         console.log('upload complete');
                     }, false);
                     xhr.addEventListener('readystatechange', e => {
                         if (xhr.readyState === 4) {
                             resolve(xhr.response);
                             this.uploadBtn.disabled = false;
                             this.uploadingOverlay.close();
                         }
                     }, false);
                     xhr.open('POST', url);
                     xhr.responseType = 'json';
                     xhr.overrideMimeType('multipart/form-data');
                     xhr.send(formData);
                 };
                 input.addEventListener('change', listener, false);
                 input.click();
             });
         }

         async loadBundle() {
             if (await this.bundlesDlg.show('Load Bundle', 'Load')) {
                 this.vars = await this.api(
                     'load_bundle', this.bundlesDlg.bundle,
                     this.bundlesDlg.toolMode);
                 elt('bundle-name').textContent = this.vars['exp_app_name'];
                 this._onBundleUpdate();
             }
         }

         async newRun() {
             if (this.run === null || await this.confirmDlg.show(
                 'Really start a new run?', 'Cancel', 'Start')) {
                 const runInfo = await this.api('start_new_run');
                 if (this.run) {
                     this.instList.addStopSeparator(this.run);
                 }
                 this.setRunInfo(runInfo);
                 this.run = runInfo.run;
             }
         }

         async reloadBundle() {
             if (await this.confirmDlg.show(
                 `Really reload '${this.vars['exp_app_name']}'?`,
                 'Cancel', 'Reload')) {
                 await this.api('reload_exper');
                 if (this.run) {
                     this.instList.addReloadSeparator(
                         this.vars['exp_app_name']);
                 }
                 this.setRunInfo({});
                 this.run = null;
             }
         }

         download(run, what) {
             const anchor = document.createElement('a');
             anchor.href = `{{ dashboard_path }}/download/${run}/${what}`;
             anchor.download = run;
             anchor.style.display = 'none';
             document.body.append(anchor);
             anchor.click();
             document.body.removeChild(anchor);
         }

         setRunInfo(info) {
             const runInfo = elt('run-info');
             runInfo.textContent = info.run ?? '<None>';
             if (info.mode === 'res') {
                 runInfo.textContent += ' res';
             } else if (info.mode === 'rep') {
                 runInfo.textContent += ' rep ' + info.target;
             }
         }

     }

     const ctrlr = await new Dashboard().init();

     /*const dummy = [
         '0123456789abcdef0123456789abcdef',
         'xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx',
         'foobar',
         'CONSENT_DECLINED',
         '999',
         '01/01/1970 00:00:00',
         '100.5'
     ];
     for (let i = 0; i < 50; i++)
         addRow(dummy);*/

    </script>
{% endblock %}

{% block exp_page_content %}
    <div id="dboard">

        <h2>EXPERt Dashboard</h2>
        <div id="status">
            <span class="status-key">Bundle:</span>
            <span id="bundle-name">&lt;None&gt;</span>
            <span class="status-key">Run:</span>
            <span id="run-info"></span>
        </div>
        <div id="controls">
            <input type="file" id="file-input" class="exp-hidden"
            webkitdirectory multiple>
            <button type="button" id="upload-btn">
                Upload Bundle to Server
            </button>
            <button type="button" id="load-btn">
                Load Bundle
            </button>
            <button type="button" id="new-run-btn" disabled>
                    {# {{'disabled' if exp_tool_mode else ''}}> #}
                Start New Run
            </button>
            <button type="button" id="reload-btn" disabled>
                Reload Bundle
            </button>
            <button type="button" id="download-btn" disabled>
                Download Results
            </button>
            {#<button type="button" id="delete-btn">
                Delete Results
            </button>#}
            <button type="button" id="download-id-btn" disabled>
                Download ID Mapping
            </button>
            <button type="button" id="delete-id-btn" disabled>
                Delete ID Mapping
            </button>
        </div>

        <div id="inst-list-header-bar">
            {% set headers = [
                '', 'ID', 'Client IP', 'Profile', 'State',
                'Task', 'Started', 'Elapsed (m)'
            ] %}
            <div id="inst-list-headers">
                {% for header in headers -%}
                    <div class="dboard-header">{{ header }}</div>
                {%- endfor %}
            </div>
        </div>
        <div id="inst-list">
            <div id="inst-data"></div>
        </div>
    </div>
{% endblock %}
