
import { elt, callApi } from '/{{ expert_js }}/util.js'

export class Task {

    constructor(debug) {
        this.debug = debug
        this.nextBtn = elt('next-btn')
        this.nextBtnWrapper = elt('next-btn-wrapper')
        this.debugBackBtn = elt('debug-back-btn')
        this.debugFwdBtn = elt('debug-fwd-btn')
        this.debugTaskCursor = elt('debug-task-cursor')
        this.content = elt('task-wrapper')

        this.reset()

        if ('{{ sid }}' !== 'None' || debug) {
            let ns = debug ? 'debug' : '{{ sid }}'
            this.socket = io(`/${ns}`)
            this.socket.on('connect', async () => {
                console.log("socket connected")
            })
            this.socket.on('disconnect', async () => {
                console.log("socket disconnected")
            })
            this.socket.on('connect_error', async () => {
                console.log("socket connection error")
            })
            this.nextBtn.addEventListener('click', async () => {
                this.disableNext()
                await this._nav('next_page', this.response)
            })
            this.debugBackBtn.addEventListener(
                'click', async () => await this._nav('debug_back'))
            this.debugFwdBtn.addEventListener(
                'click', async () => await this._nav('debug_fwd'))
        }
    }

    async _nav(...apiParams) {
        let vars = await this.api(...apiParams)
        if (vars['task_type'] === this.vars['task_type']) {
            this.vars = vars
            this.debugTaskCursor.textContent = vars['task_cursor']
            this.reset()
            this.initFunc(this)
        } else {
            // moving on to a new task type
            location.reload()
        }
    }

    init(f) {
        this.initFunc = f
        this.socket.emit('init_task', vars => {
            this.vars = vars
            f(this)
        })
    }

    reset() {
        this.guide(null)
        this.response = null
        this.content.scrollTo(0, 0)
        window.scrollTo(0, 0)
    }

    async api(func, args) {
        return await callApi(this.socket, func, args)
    }

    enableNext() {
        this.nextBtn.disabled = false
        this.guide(this.nextBtn)
    }

    disableNext() {
        this.nextBtn.disabled = true
        this.guide(null)
    }

    setResponse(response) {
        this.response = response
    }

    guide(guideElt) {
        if (this.guideElt) {
            this.guideElt.classList.remove('guide')
        }
        if (guideElt) {
            guideElt.classList.add('guide')
        }
        this.guideElt = guideElt
    }

    // Pre-load a sound
    loadSound(sound) {
        return new Audio(
            `/{{ expert_url_prefix }}/{{ exper }}/audio/${sound}.mp3`)
    }
}

export class FSA {
    constructor(task, transitTable) {
        this.task = task
        this.transitTable = transitTable
    }

    event(sym) {
        let transits = this.transitTable[this.state]
        if (transits === undefined) {
            return
        }
        let destState = transits[sym]
        // symbols without transitions are treated as loops
        if (destState !== undefined) {
            this.enter(destState)
        }
    }

    enter(state) {
        this.state = state
        let f = this[state]
        if (f !== undefined) {
            f.apply(this)
        }
    }
}
